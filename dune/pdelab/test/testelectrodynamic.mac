/* -*- maxima -*- */

/* define antisymmetric matrices */
I01: matrix([ 0, 1, 0],
            [-1, 0, 0],
            [ 0, 0, 0]);
I02: matrix([ 0, 0, 1],
            [ 0, 0, 0],
            [-1, 0, 0]);
I12: matrix([ 0, 0, 0],
            [ 0, 0, 1],
            [ 0,-1, 0]);

I: [I01, I02, I12];

/* define vertices of cube */
xi: [matrix([0], [0], [0]),
     matrix([1], [0], [0]),
     matrix([0], [1], [0]),
     matrix([1], [1], [0]),
     matrix([0], [0], [1]),
     matrix([1], [0], [1]),
     matrix([0], [1], [1]),
     matrix([1], [1], [1])
     ];

/* define table of edges */
edges: [[0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7],
        [1,3], [1,5], [1,7],
        [2,3], [2,6], [2,7],
        [3,7],
        [4,5], [4,6], [4,7],
        [5,7],
        [6,7]];

/* define tet -> edge mapping */
tet_edge: [[ 0, 2, 7, 6, 9,13],
           [ 1, 2,10, 6,12,13],
           [ 1, 5,11, 6,12,18],
           [ 3, 5,15, 6,16,18],
           [ 3, 4,14, 6,16,17],
           [ 0, 4, 8, 6, 9,17]];

/* define tet -> vertex mapping */
tet_vertex: makelist(sort(unique(apply(append,makelist(edges[i+1],i,tet_edge[j+1])))),j,0,5);

local_edge: [[0,1], [0,2], [1,2], [0,3], [1,3], [2,3]];

/* tet_coords[j+1][i+1] = coords of the i'th vertex of tet j */
tet_coords: makelist(makelist(xi[i+1],i,tet_vertex[j+1]),j,0,5);

/* define matrices, one for each tet */
M: makelist(/* tet j */
            apply(matrix,
                  makelist(/* row r */
                           append(makelist(tet_coords[j+1][local_edge[r+1][2]+1].myI.tet_coords[j+1][local_edge[r+1][1]+1],
                                           myI,I),
                                  makelist((tet_coords[j+1][local_edge[r+1][2]+1]-tet_coords[j+1][local_edge[r+1][1]+1])[i+1][1],
                                           i,0,2)),
                           r,0,5)
                  ),
            j,0,5);

Minv: makelist(invert(m),m,M);

/* right hand sides */

r: makelist(/* tet j */
            makelist(/* edge i */
                     ematrix(6,1,
                             sqrt((tet_coords[j+1][local_edge[i+1][2]+1]-tet_coords[j+1][local_edge[i+1][1]+1])^^2)[1][1],
                             i+1,1),
                     i,0,5
                     ),
            j,0,5
            );

coeff: makelist(/* tet j */
                makelist(/* edge i */
                         Minv[j+1].r[j+1][i+1],
                         i,0,5
                         ),
                j,0,5
                );

A: makelist(/* tet j */
            makelist(/* edge i */
                     coeff[j+1][i+1][1][1]*I01+coeff[j+1][i+1][2][1]*I02+coeff[j+1][i+1][3][1]*I12,
                     i,0,5
                     ),
            j,0,5
            );

a: makelist(/* tet j */
  makelist(/* edge i */
    submatrix(1,2,3,coeff[j+1][i+1]),
    i,0,5),
  j,0,5);

psihat: makelist(makelist(apply(lambda, [[x], A[j+1][i+1].matrix([x[1][1]],[x[2][1]],[x[3][1]])+a[j+1][i+1]]),i,0,5),j,0,5);

rot(f):=matrix(
  [diff(f(x)[3][1],x[2][1])-diff(f(x)[2][1],x[3][1])],
  [diff(f(x)[1][1],x[3][1])-diff(f(x)[3][1],x[1][1])],
  [diff(f(x)[2][1],x[1][1])-diff(f(x)[1][1],x[2][1])]);

rotpsihat: makelist(makelist(rot(psihat[j+1][i+1]),i,0,5),j,0,5);

tet_permutation: [
  [0,1,2],
  [1,0,2],
  [1,2,0],
  [2,1,0],
  [2,0,1],
  [0,2,1]];

tet_permute(tet, x):= [x[tet_permutation[tet+1][1]+1],x[tet_permutation[tet+1][2]+1],x[tet_permutation[tet+1][3]+1]];

tet_integrate: makelist(apply(lambda, [[f], integrate(integrate(integrate(f(apply(matrix,tet_permute(i,[[x0],[x1],[x2]]))),x2,0,x1),x1,0,x0),x0,0,1)]),i,0,5);

T_tet: makelist(zeromatrix(length(edges), length(edges)), i, 0, 5);
for el: 0 thru 5 do for ed1: 0 thru 5 do for ed2: 0 thru 5 do
  setelmx(
    ev(tet_integrate[el+1](lambda([x], psihat[el+1][ed1+1](x).psihat[el+1][ed2+1](x))),nouns),
    tet_edge[el+1][ed1+1]+1, tet_edge[el+1][ed2+1]+1,
    T_tet[el+1]);

T: lsum(t,t,T_tet)$

ev(T,float);

