/* -*- maxima -*- */

/* define antisymmetric matrices */
I01: matrix([ 0, 1, 0],
            [-1, 0, 0],
            [ 0, 0, 0])$
I02: matrix([ 0, 0, 1],
            [ 0, 0, 0],
            [-1, 0, 0])$
I12: matrix([ 0, 0, 0],
            [ 0, 0, 1],
            [ 0,-1, 0])$

I: [I01, I02, I12]$

/* permutation for each tet */
tet_permutation: [[1,2,3],
                  [2,1,3],
                  [2,3,1],
                  [3,2,1],
                  [3,1,2],
                  [1,3,2]]$
tet_permute(tet, x):= [x[tet_permutation[tet][1]],x[tet_permutation[tet][2]],x[tet_permutation[tet][3]]]$

/* unit vectors */
unit_vector: makelist(ematrix(3,1, 1, i,1),i,1,3)$

/* define vertices of cube */
xi: [matrix([0], [0], [0]),
     matrix([1], [0], [0]),
     matrix([0], [1], [0]),
     matrix([1], [1], [0]),
     matrix([0], [0], [1]),
     matrix([1], [0], [1]),
     matrix([0], [1], [1]),
     matrix([1], [1], [1])]$

/* tet_coords[tet][i] = coords of the i'th vertex of tet tet */
tet_coords: makelist(makelist(zeromatrix(3,1),i,1,4),tet,1,6)$
for tet: 1 thru 6 do
  for i: 1 thru 3 do
    tet_coords[tet][i+1]: tet_coords[tet][i]+unit_vector[tet_permutation[tet][i]]$

/* */
lindex(l, v) := block(
  for i: 1 thru length(l) do
    if equal(l[i], v) then return(i))$

/* mapping local->global vertex numbers */
tet_vertex: makelist(makelist(lindex(xi,tet_coords[tet][i]),i,1,4),tet,1,6)$

/* the local edges, including ordering */
local_edge: [[1,2], [1,3], [2,3], [1,4], [2,4], [3,4]]$

/* define table of edges */
edges: unique(sort(apply(append, makelist(makelist(sort(makelist(tet_vertex[tet][l],l,local_edge[e])),e,1,6),tet,1,6))))$

/* define tet/edge -> global edge mapping */
tet_edges: makelist(/* tet tet */
  makelist(/* edge e */
    lindex(
      edges,
      sort(
        makelist(
          tet_vertex[tet][l],
          l,
          local_edge[e]))),
    e,1,6),
  tet,1,6)$

/* define matrices, one for each tet */
M: makelist(/* tet tet */
  block([coords],
    coords: tet_coords[tet],
    apply(
      matrix,
      makelist(/* row r */
        block([edge, x1, x2],
          edge: local_edge[r],
          x1: coords[edge[1]],
          x2: coords[edge[2]],
          append(
            makelist(
              x2.myI.x1,
              myI,I),
            makelist(
              (x2-x1)[i][1],
              i,
              1,3))),
        r,1,6))),
  tet,1,6)$

Minv: makelist(invert(m),m,M)$

/* right hand sides */
r: makelist(/* tet tet */
  block([coords],
    coords: tet_coords[tet],
    makelist(/* edge e */
      block([edge, x1, x2],
          edge: local_edge[e],
          x1: coords[edge[1]],
          x2: coords[edge[2]],
        ematrix(
          6,1,
          sqrt((x2-x1)^^2)[1][1],
          e,1)),
      e,1,6)),
  tet,1,6)$

/* coefficient vector for the shape functions */
coeff: makelist(/* tet tet */
  makelist(/* edge e */
    Minv[tet].r[tet][e],
    e,1,6),
  tet,1,6)$



/* coefficient matrices */
A: makelist(/* tet tet */
  block([tc],
    tc: coeff[tet],
    makelist(/* edge e */
      block([ec],
        ec: tc[e],
        sum(
          ec[i][1]*I[i],
          i,1,3)),
      e,1,6)),
  tet,1,6)$


a: makelist(/* tet tet */
  makelist(/* edge e */
    submatrix(1,2,3,coeff[tet][e]),
    e,1,6),
  tet,1,6)$

assert_vector(x) := matrix([x[1][1]],[x[2][1]],[x[3][1]])$

psihat: makelist(/* tet tet */
  block([tA, ta],
    tA: A[tet],
    ta: a[tet],
    makelist(/* edge e */
      block([eA, ea],
        eA: tA[e],
        ea: ta[e],
        apply(
          lambda,
          [[x],
           eA.assert_vector(x)+ea])),
      e,1,6)),
  tet,1,6)$

rot(f):=matrix(
  [diff(f(x)[3][1],x[2][1])-diff(f(x)[2][1],x[3][1])],
  [diff(f(x)[1][1],x[3][1])-diff(f(x)[3][1],x[1][1])],
  [diff(f(x)[2][1],x[1][1])-diff(f(x)[1][1],x[2][1])])$

rotpsihat: makelist(/* tet tet */
  makelist(/* edge e */
    rot(psihat[tet][e]),
    e,1,6),
  tet,1,6)$

tet_integrate: makelist(/* tet tet */
  block([p,x,xp],
    p: tet_permutation[tet],
    x: matrix(['x1],['x2],['x3]),
    xp: makelist(x[i][1],i,p),
    apply(
      lambda,
      [[f],
      integrate(
        integrate(
          integrate(
            f(x),
            xp[3],0,xp[2]),
          xp[2],0,xp[1]),
        xp[1],0,1)])),
  tet,1,6)$

T_tet: makelist(zeromatrix(length(edges), length(edges)), tet, 1, 6)$
for tet: 1 thru 6 do block([ti,tpsi,te,tT],
  ti: tet_integrate[tet],
  tpsi: psihat[tet],
  te: tet_edges[tet],
  tT: T_tet[tet],
  for e1: 1 thru 6 do
    for e2: 1 thru 6 do block([integrand],
      integrand(x) := tpsi[e1](x).tpsi[e2](x),
      setelmx(
        ev(ti(integrand),nouns),
        te[e1], te[e2],
        tT)))$
T: lsum(t,t,T_tet)$

S_tet: makelist(zeromatrix(length(edges), length(edges)), tet, 1, 6)$
for tet: 1 thru 6 do block([ti,tpsi,te,tS],
  ti: tet_integrate[tet],
  trotpsi: rotpsihat[tet],
  te: tet_edges[tet],
  tS: S_tet[tet],
  for e1: 1 thru 6 do
    for e2: 1 thru 6 do block([integrand],
      integrand(x) := trotpsi[e1].trotpsi[e2],
      setelmx(
        ev(ti(integrand),nouns),
        te[e1], te[e2],
        tS)));
S: lsum(t,t,S_tet)$

nonconstrained: {7}$
constrained: setdifference(setify(makelist(e,e,1,length(edges))),nonconstrained)$

Jac: copy(T)$
for i in constrained do block(
  for j: 1 thru length(Jac) do block(
    Jac[i][j]: 0,
    Jac[j][i]: 0),
  Jac[i][i]: 1)$

affine_shift: zeromatrix(length(Jac),1)$

xprev: copy(affine_shift)$
xprev[7][1]: -1/sqrt(3)$

xcur: copy(xprev)$

Delta_t: sqrt(1/3)$

steps: floor(10/Delta_t)$

result: [copy(xprev), copy(xcur)]$

rhs: -copy(T.(affine_shift-2*xcur+xprev)+Delta_t^2*S.xprev)$
for i in constrained do
  rhs[i][1]: 0$

dJac: apply(submatrix, append(listify(constrained), [Jac], listify(constrained)))$

dJinv: invert(dJac)$

for s: 1 thru steps do block([rhs, drhs, dxnext, xnext, j],
  rhs: -copy(T.(affine_shift-2*xcur+xprev)+Delta_t^2*S.xprev),
  drhs: apply(submatrix, append(listify(constrained), [rhs])),
  dxnext: dJinv.drhs,
  xnext: copy(affine_shift),
  j: 1,
  for i in nonconstrained do block(
    xnext[i]: xnext[i]+dxnext[j],
    j=j+1),
  result: endcons(xnext, result),
  xprev: xcur,
  xcur: xnext)$

makelist(apply(submatrix, append(listify(constrained), [x])),x,result);
